// Generated by CoffeeScript 1.10.0
(function() {
  var ARCHIVE_TAG, IMAGE_URL, Q, TEST_TAG, _, api, cloudinary, exec, execSync, expect, fs, helper, http, https, includeContext, os, sharedExamples, sinon, uploader, utils, zlib;

  require('dotenv').load();

  http = require('http');

  https = require('https');

  expect = require("expect.js");

  cloudinary = require("../cloudinary");

  utils = cloudinary.v2.utils;

  api = cloudinary.v2.api;

  uploader = cloudinary.v2.uploader;

  zlib = require('zlib');

  sinon = require("sinon");

  exec = require('child_process').exec;

  execSync = require('child_process').execSync;

  _ = require("lodash");

  Q = require('q');

  fs = require('fs');

  os = require('os');

  helper = require("./spechelper");

  TEST_TAG = helper.TEST_TAG;

  IMAGE_URL = helper.IMAGE_URL;

  sharedExamples = helper.sharedExamples;

  includeContext = helper.includeContext;

  ARCHIVE_TAG = TEST_TAG + "_archive";

  sharedExamples('archive', function() {
    before(function(done) {
      this.timeout(helper.TIMEOUT_LONG);
      return Q.all([
        uploader.upload(IMAGE_URL, {
          public_id: 'tag_samplebw',
          tags: helper.UPLOAD_TAGS.concat([ARCHIVE_TAG]),
          transformation: {
            effect: "blackwhite"
          }
        }), uploader.upload(IMAGE_URL, {
          public_id: 'tag_sample',
          tags: helper.UPLOAD_TAGS.concat([ARCHIVE_TAG]),
          transformation: {
            effect: "blackwhite"
          }
        })
      ])["finally"](function() {
        return done();
      });
    });
    after("Verify Configuration", function() {
      var config;
      config = cloudinary.config(true);
      if (!(config.api_key && config.api_secret)) {
        return expect().fail("Missing key and secret. Please set CLOUDINARY_URL.");
      }
    });
    return after(function() {
      if (!cloudinary.config().keep_test_products) {
        return cloudinary.v2.api.delete_resources_by_tag(TEST_TAG);
      }
    });
  });

  describe("utils", function() {
    before("Verify Configuration", function() {
      var config;
      config = cloudinary.config(true);
      if (!(config.api_key && config.api_secret)) {
        return expect().fail("Missing key and secret. Please set CLOUDINARY_URL.");
      }
    });
    includeContext.call(this, 'archive');
    return describe('.generate_zip_download_url', function() {
      var archive_result;
      this.timeout(helper.TIMEOUT_LONG);
      archive_result = void 0;
      before(function() {
        return archive_result = utils.download_zip_url({
          target_public_id: 'gem_archive_test',
          public_ids: ["tag_sample", "tag_samplebw"],
          target_tags: ARCHIVE_TAG
        });
      });
      return describe('public_ids', function() {
        it('should generate a valid url', function() {
          return expect(archive_result).not.to.be.empty();
        });
        return it('should include two files', function(done) {
          var filename;
          filename = (os.tmpdir()) + "/deleteme-" + (Math.floor(Math.random() * 100000)) + ".zip";
          return https.get(archive_result, function(res) {
            var file;
            file = fs.createWriteStream(filename);
            if (res.statusCode === 200) {
              res.pipe(file);
            } else {
              done(new Error(res.statusCode + ": " + res.headers['x-cld-error']));
            }
            return res.on('end', function() {
              return file.on('close', function() {
                var i, list;
                list = execSync("unzip -l " + filename);
                list = list.toString().split('\n').slice(3, -3);
                list = (function() {
                  var j, len, results;
                  results = [];
                  for (j = 0, len = list.length; j < len; j++) {
                    i = list[j];
                    results.push(_.last(i.split(/[ ]+/)));
                  }
                  return results;
                })();
                expect(list.length).to.eql(2);
                expect(list).to.contain("tag_sample.jpg");
                expect(list).to.contain("tag_samplebw.jpg");
                return done();
              });
            });
          });
        });
      });
    });
  });

  describe("uploader", function() {
    before("Verify Configuration", function() {
      var config;
      config = cloudinary.config(true);
      if (!(config.api_key && config.api_secret)) {
        return expect().fail("Missing key and secret. Please set CLOUDINARY_URL.");
      }
    });
    includeContext.call(this, 'archive');
    describe('.create_archive', function() {
      var archive_result, expected_keys;
      this.timeout(helper.TIMEOUT_LONG);
      archive_result = void 0;
      before(function(done) {
        this.timeout(helper.TIMEOUT_LONG);
        return uploader.create_archive({
          target_public_id: 'gem_archive_test',
          public_ids: ["tag_sample", "tag_samplebw"],
          target_tags: [TEST_TAG, ARCHIVE_TAG],
          mode: 'create'
        }, function(error, result) {
          if (error != null) {
            return done(new Error(error.message));
          }
          archive_result = result;
          return done();
        });
      });
      it('should return a Hash', function() {
        return expect(archive_result).to.be.an(Object);
      });
      expected_keys = ["resource_type", "type", "public_id", "version", "url", "secure_url", "created_at", "tags", "signature", "bytes", "etag", "resource_count", "file_count"];
      return it("should include keys: " + (expected_keys.join(', ')), function() {
        return expect(archive_result).to.have.keys(expected_keys);
      });
    });
    return describe('.create_zip', function() {
      var spy;
      this.timeout(helper.TIMEOUT_LONG);
      spy = void 0;
      before(function() {
        return spy = sinon.spy(cloudinary.uploader, "create_archive");
      });
      after(function() {
        return spy.reset();
      });
      return it('should call create_archive with "zip" format', function() {
        uploader.create_zip({
          tags: TEST_TAG
        });
        return expect(spy.calledWith(null, {
          tags: TEST_TAG
        }, "zip")).to.be.ok();
      });
    });
  });

}).call(this);

//# sourceMappingURL=archivespec.js.map
